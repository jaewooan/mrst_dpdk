function polygons = computeGridSlicePolygons(G, coord, varargin)
% Compute polygons generated by intersection of grid and plane(s). The two 
% modes are:
% 1) Single coord: optional argument 'normal' is used to determine plane. 
%    Intersection can furter be restricted by optional input parameters 
%    'radius' and 'axis'
% 2) Multiple coord: optional argument 'cutDir' is used to determine plane. 
%    Slices grid along segment(s) defined be coord. Slice width can be 
%    controlled by optional argumet 'radius'
% vertical s
%
% SYNOPSIS:
%   poly = computeVerticalGridIntersection(G, segments)
%
% DESCRIPTION:
%
%
% REQUIRED PARAMETERS:
%
%   G        - Grid structure with geometry and preferably 'bbox'-field included
%              for G.faces (see addBoundingBoxFields)
%
%   coords   - Nx3 matrix. Any N>0 number of coords.   
%              If N ==1, a single cut-plane is defined by point and optional 
%              parameter 'normal'.
%              If N >= 2, N-1 connected planar slices are produced where slice k
%              is the set of coords given by 
%                  s*coords(k,:) + (1-s)*coords(k+1,:) + t*cutDir
%              with 0<=s<=1. Slicing direction must be given by optional
%              parameter 'cutDir'.
% OPTIONAL PARAMETERS:
%  'faceIx'  : Consider only subset of faces. 
%              Default: 1:G.faces.num
%  'cellIx'  : Consider only subset of faces as given by subset of cells.
%              Default: 1:G.cells.num
%  'cutDir'  : 3x1 vector (or 'x','y','z') giving "slicing" direction. 
%              If N==1, this input is ignored. For canonical directions, a 
%              slight performance gain is obtained by e.g., setting 
%              cutDir = 'x' rather than cutDir = [1 0 0]'
%              Default: 'z' (or determined from cut-plane)
%  'normal'  : 3x1 vector (or 'x','y','z') giving normal direction to 
%              cut-plane. If N>=2, this input is ignored. For canonical 
%              directions, a slight performance gain is obtained by e.g., 
%              setting cutDir = 'x' rather than cutDir = [1 0 0]'
%              Default: 'x' (or determined from coords and cutDir)
%  'radius'  : If N == 1:
%                 1xd vector d = 1 or 3. Restricts slice(s) to ellipse. In
%                 particular:
%                 d == 1: restrict to ball with given radius
%                 d == 3: restrict to ellipsoid with given radii
%              If N >= 1: 
%                 scalar giving half width of slice
%              Default: empty (no restriction)
% 'axis'     : 3x3 matrix where each column give principal axis of 
%              ellipsoid 
%              Deafault: eye(3)
% 
% EXAMPLE:
%%
% G  = addBoundingBoxFields(computeGeometry(cartGrid([20 20 10])));
% poly = computeGridSlicePolygons(G, [15*sin((0:.1:2))', .5*cos(0:.1:2)', (0:.1:2)'], 'cutDir', [0 0 1]);
% patch('Faces', poly.nodes, 'Vertices', poly.coords3D, 'FaceColor', 'y')
% view(3)
%%
%{
Copyright 2009-2021 SINTEF Digital, Mathematics & Cybernetics.

This file is part of The MATLAB Reservoir Simulation Toolbox (MRST).

MRST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MRST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MRST.  If not, see <http://www.gnu.org/licenses/>.
%}
opt = struct('faceIx',                      [], ...
             'cellIx',                      [], ...
             'cutDir',                      [], ...
             'radius',                      [], ...
             'normal',                      [], ...
             'axis',                    eye(3), ...
             'removeRepeated',           false, ...
             'removeDegenerates',         true, ...
             'removeFullyClamped',        true, ...
             'removePartialCuts',        false, ...
             'outputForGridProcessing',  false, ...
             'tol',                       1e-6, ...
             'parallellTol',              1e-6, ...
             'snapTol',                      0);
opt = merge_options(opt, varargin{:}); 

[seg, cutDir, r, opt] = processInput(G, coord, opt);

[tol, parTol, snapTol] = deal(opt.tol, opt.parallellTol, opt.snapTol);

% Add face bounding boxes if not present
if ~isfield(G.faces, 'bbox')
    G = addBoundingBoxFields(G);
end

% If multiple segments, pick initial subset of faces covering all
% segProj  = seg - (seg*cutDir)*cutDir';  ??
nseg = size(seg,1)-1;
if nseg > 1
    fix0 = getFacesCloseToSegment(G, seg, 'projVec', cutDir, 'faceIx', opt.faceIx);
else
    fix0 = opt.faceIx;
end
% prealocate for polygon vertices, p is coord, t length along segment
intsec = repmat(struct('p', [], 'faceNo', [], 'nodePos', [], ...
                       't', [], 'sValue', [], 'isClamped', [], ...
                       'snapNode', []), [nseg, 1]);
ts     = 0;
np     = size(coord, 1);
cumlen = zeros(nseg+1, 1);

% Main loop ---------------------------------------------------------------

for k = 1:nseg
    curseg     = seg([k, k+1],:);
    fix = getFacesCloseToSegment(G, curseg, 'faceIx', fix0, 'projVec', cutDir);
    % skip second round of subset reduction, not fully robust
    %if ~isempty(r)
    %   fix = shapeSubset(G, fix, curseg, cutDir, r);
    %end
    
    % Collect all segments for current set of faces
    segments = getFaceSegments(G, fix, opt.outputForGridProcessing);
    v  = diff(curseg);
    vu = v(:)/norm(v(:));
    % cut-plane : n'x = d 
    n = null([vu';cutDir']);
    assert(size(n,2)==1, 'Invalid slicing direction')
    d = curseg(1,:)*n;
    
    % Compute segment - plane intersections
    intsec(k) = getPlaneIntersections(intsec(k), segments, n, d, tol, parTol, snapTol);
    if np >= 2
        % For a given segment remove intersections that don't project to 0 < t < tmax 
        % except for first and last segments where points are clamped  
        [isFirst, isLast] = deal(k == 1, k == nseg);
        intsec(k) = clampSides(intsec(k), curseg, r, cutDir, n, isFirst, isLast, opt.removePartialCuts);
    else
        % clamping/removing is only performed if r's are finite
        intsec(k) = clampEllipsoid(intsec(k), curseg, r, cutDir, opt.removePartialCuts);
    end
    % keep track of parameter t along segments
    intsec(k).t = ts + intsec(k).t;
    ts          = ts + norm(v);   % final t for current segment
    cumlen(k+1) = ts;
end

% Collect and reshape -----------------------------------------------------
intsec = vertcatStructFields(intsec);

% Reshape intersection info to all intersected grid cells
cno   = G.faces.neighbors(intsec.faceNo,:); 
isPos = cno > 0;
cno   = [cno(isPos(:,1),1); cno(isPos(:,2),2)];
pix   = [find(isPos(:,1)); find(isPos(:,2))];

intsec = reindexNonEmpty(intsec, pix);

if isempty(cno)
    polygons = [];
    warning('Empty set of intersected cells')
    return;
end

% reindex to local cell-map
cix = unique(cno);
if cix(1) == 0
    cix = cix(2:end);
end
rix     = sparse(cix, 1, (1:numel(cix))', G.cells.num, 1);
cno_loc = full(rix(cno));
% compute current number of vertices for each polygon
nvert   = accumarray(cno_loc, ones(size(cno_loc)), [numel(cix), 1]);

% Orientation of vertices -------------------------------------------------

% project intersection points onto 2D (t, p_cut) -plane and orient polygon 
% vertices accoring to angle wrt poly center
p_cut = intsec.p*cutDir - seg(1,:)*cutDir;
pp    = [intsec.t, p_cut];
cent  = [accumarray(cno_loc, pp(:,1)), accumarray(cno_loc, pp(:,2))]./nvert;
rp    = pp - cent(cno_loc,:);
theta = atan2(rp(:,2), rp(:,1));
[info, order] = sortrows([cno_loc, theta]);

polyIx = ':';

% Polynom processing ------------------------------------------------------

% typically many repeated nodes, these are needed in subsequent
% grid-processing, otherwise can be removed
if opt.removeRepeated
    isSame  = [false; diff(info(:,1)) == 0 & abs(diff(info(:,2))) < sqrt(eps)];
    order   = order(~isSame);
end
cno_loc = cno_loc(order);
% recompute number of vertices 
nvert  = accumarray(cno_loc, ones(size(cno_loc)), [numel(cix), 1]);

% optionally remove clamped and/or degenerate cells 
if opt.removeDegenerates || opt.removeFullyClamped
    nfixed = 1;
    if opt.removeFullyClamped
        nfixed = accumarray(cno_loc, ~intsec.isClamped(order), [numel(cix), 1]);
    end
    isDeg = false;
    if opt.removeDegenerates
        isDeg = nvert <= G.griddim -1;
    end
    polyIx = ~isDeg & nfixed >=1;
    orderIx = rldecode(polyIx, nvert);
    % reindex to subset
    nvert    = nvert(polyIx);
    order    = order(orderIx);
    cno_loc  = cno_loc(orderIx);
end

% Assemble output ---------------------------------------------------------
intsec = reindexNonEmpty(intsec, order);
p_cut = p_cut(order);
% do snapping:
if ~isempty(intsec.snapNode)
    ii = ~isnan(intsec.snapNode);
    if any(ii)
        intsec.p(ii,:) = G.nodes.coords(intsec.snapNode(ii),:);
    end
end

cno = cix(cno_loc);

% Construct polygonal info
maxp  = max(nvert);
npol  = numel(nvert);
cumc  = cumsum(nvert);
pos   = [1; cumc(1:end-1)+1];
if ~opt.outputForGridProcessing
    % arrange nodes in matrix for use in patch
    nodes = zeros(npol, maxp);
    cl    = (1:numel(cno))';
    for k = 1:maxp
        nodes(:,k) =  cl(min(pos+k-1, cumc));
    end
    polygons = struct('nodes',                nodes, ...
                      'coords3D',          intsec.p, ...
                      'coords2D', [intsec.t, p_cut], ...
                      'cellIx',         cix(polyIx), ...
                      'segments',               seg, ...
                      'cumlength',           cumlen);
else
    cellIx = rldecode(cix(polyIx), nvert);
    polygons = struct('nodePos',         [1;cumc+1], ...
                      'coords3D',          intsec.p, ...
                      'coords2D', [intsec.t, p_cut], ...
                      'cellIx',              cellIx, ...
                      'segments',               seg, ...
                      'cumlength',           cumlen, ...
                      'faceIx',       intsec.faceNo, ...
                      'locPos',      intsec.nodePos, ...
                      'tValue',       intsec.sValue, ...
                      'snapNode',   intsec.snapNode);
end
end

% -------------------------------------------------------------------------
% -------------------------------------------------------------------------
function segments = getFaceSegments(G, f, outputNodeIndex)
[np1, np2] = deal(G.faces.nodePos(f), G.faces.nodePos(f+1));
nNodes = np2-np1;
nSeg   = numel(nNodes);
faceNo = rldecode(f(:), nNodes);

nodes = G.faces.nodes(mcolon(np1, np2-1));
locpos = [1; cumsum(nNodes)+1];
next   = (2:numel(nodes)+1) .';
next(locpos(2 : end) - 1) = locpos(1 : end-1);

p1 = G.nodes.coords(nodes,:);
p2 = G.nodes.coords(nodes(next),:);
[nodeNo, nodeIx] = deal([]);
if outputNodeIndex
    nodeNo = [nodes, nodes(next)];
    nix1 = mcolon(ones(nSeg, 1), nNodes)';
    nix2 = nix1(next);
    nodeIx = [nix1, nix2];
end
segments = struct('p1', p1, 'p2', p2, 'faceNo', faceNo, ...
                  'nodeNo', nodeNo, 'nodeIx', nodeIx);
end

% -------------------------------------------------------------------------
function intsec = getPlaneIntersections(intsec, segments, n, d, segTolRel, parTol, segTolAbs)
% compute intersection points of line-segments with plane
[p1, p2] = deal(segments.p1, segments.p2);
v  = p2-p1;
normv = sqrt(sum(v.^2,2));

vn = v*n;
%ok = abs(vn) > parTol*norm(max(v));
ok = abs(vn) > parTol*normv;
s  = nan(size(vn));
s(ok)  = -(p1(ok,:)*n-d)./vn(ok);
if ~all(ok) % check if in plane
    ii = abs((p1(~ok,:)*n-d)./d) < parTol;
    if any(ii)
        tii     =  nan(size(ii));
        tii(ii) = 0;
        s(~ok)  = tii;
    end
end
% Might want to consider a tollerance in next line but this will 
% potentially screw up later logic. However, if there is a finite 
% tol such that tol/(magnitude of coordinates) is sufficenlty 
% many orders og magnitude larger than eps, this should be OK 
ix = find(s>=0 & s <= 1);
s  = s(ix);
p  = p1(ix,:) + bsxfun(@times, s, v(ix,:));
if (segTolRel > 0 || segTolAbs > 0) && ~isempty(s)
    snapNode = nan(size(s));
    tolr = 0;
    if segTolAbs > 0
        tolr = segTolAbs./normv(ix);
    end
    tol = max(segTolRel, tolr);
    six0 = s <= min(tol, .5);
    six1 = s >  max(1-tol, .5);
    s(six0) = 0;
    s(six1) = 1;
    if ~isempty(segments.nodeNo)
        snapNode(six0) = segments.nodeNo(ix(six0),1);
        snapNode(six1) = segments.nodeNo(ix(six1),2);
    end
else
    snapNode = [];
end
intsec.p        = p;
intsec.faceNo   = segments.faceNo(ix);
if ~isempty(segments.nodeIx)
    intsec.nodePos  = segments.nodeIx(ix, 1);
end
intsec.snapNode = snapNode;
intsec.sValue   = s;
end

% -------------------------------------------------------------------------
function [segments, cutDir, radius, opt] = processInput(G, coord, opt)
[cutDir, radius, normal] = deal(opt.cutDir(:), opt.radius, opt.normal(:));
% check that cut-plane is sufficiently defined
np = size(coord, 1);
if np == 1
    if isempty(normal)
        error('Input of a single point requires additional input of cut-plane normal');
    elseif ~isempty(cutDir)
        warning('Redundant input: ''cutDir'' will be ignored');
        cutDir = [];
    end
else %(np > 1)
    if isempty(cutDir)
        error('Input of multiple coords requires additional input of  optional arguemt ''cutDir''');
    elseif ~isempty(normal)
        warning('Redundant input: ''normal'' will be ignored');
        normal = [];
    end
end
if np > 1
    segments = coord;
    if isempty(cutDir)
        cutDir   = [0 0 1]';
    end
else % cut-plane given point + normal
    normal = normal/norm(normal);
    if any(~isfinite(radius)), radius = []; end
    if numel(radius) <= 1
        if isempty(radius) % need to find sufficient radius to cover grid
            radius_tmp = norm(max(G.nodes.coords) - min(G.nodes.coords));
        else
            radius_tmp = radius;
        end
        % find some direction orthogoanl to normal
        tmp = null(normal');
        v   = tmp(:,1);
        segments = [coord - radius_tmp*v'; coord + radius_tmp*v'];
        cutDir   = tmp(:,2);
    else
        Q = opt.axis;
        if norm(Q'*Q-eye(3)) > sqrt(eps)
            warning('Supplyed axis does not appear to be orthogonal');
            Q = orth(Q);
        end        
        % find cut-plane ellipse
        [radius, Q] = getEllipse(normal, radius, Q);
        % select segment and cutDir based on radius/axis
        segments = [coord - radius(1)*Q(:,1)'; coord + radius(1)*Q(:,1)'];
        cutDir   = Q(:,2);
        radius   = radius(2);
    end
end
cutDir = cutDir(:)/norm(cutDir);
% also check that cutDir is meaningfull wrt coord
V = diff(segments, 1);
V = bsxfun(@rdivide, V, sqrt(dot(V,V,2)));
ip = V*cutDir;
if any(sign(ip(1)) ~= sign(ip))
%    error('Slicing direction is parallell to line segment')
end
% check options
if opt.outputForGridProcessing && opt.removeRepeated
    warning('Option ''removeRepeated'' reset to false since grid/n%s', ...
            'processing output was requested');
   opt.removeRepeated = false; 
end   
% process cellIx subset
if ~isempty(opt.cellIx)
    if ~isempty(opt.faceIx)
        warning('Disregarding option ''cellIx'' due to non-empty ''faceIx''.')
    else
        % derive unique list of faces for given cells
        N = G.faces.neighbors;
        tmp = false(G.cells.num,1);
        tmp(opt.cellIx) = true;
        N(N>0) = tmp(N(N>0));
        opt.faceIx = find(any(N,2));
    end
end
end

% -------------------------------------------------------------------------
%{
function fix = shapeSubset(G, fix, seg, cutDir, r) 
% distance to segment in cutDir-direction
orthSeg = [seg(1,:)-r*cutDir'; seg(1,:)+r*cutDir'];
fix = getFacesCloseToSegmentNew(G, orthSeg, 'projVec', diff(seg), 'faceIx', fix);
end
%}

% -------------------------------------------------------------------------
function intsec = clampSides(intsec, seg, r, cutDir, n, isFirst, isLast, deleteOutside)
% clamp point p to t-endpoint te: p->p+(te-v.p)v
removed = false;
p = intsec.p;
clamped = false(size(p,1), 1);
segProj = seg - (seg*cutDir)*cutDir';
v  = diff(segProj)';
l  = norm(v);
vu = v/l;
t = p*vu - segProj(1,:)*vu;
ixf = t < -sqrt(eps);
if isFirst
    % project along v to t = 0
    p(ixf,:) = p(ixf,:) - t(ixf)*vu';
    t(ixf)   = 0;
    clamped = clamped | ixf;
else
    removed = removed | ixf;
end
ixl = t > l+sqrt(eps);
if isLast
    % project along v to t = l
    p(ixl,:) = p(ixl,:) - (t(ixl)-l)*vu';
    t(ixl)   = l;
    clamped = clamped | ixl;
else
    removed = removed | ixl;
end
% t is length along segments, hence scale from segProj -> seg
t = (norm(diff(seg))/norm(v))*t;
% for finite r, project along cutDir
if ~isempty(r) && isfinite(r)
    % r in cutDir - direction
    % first find normal distance to segment
    v  = diff(seg)';
    v  = v/norm(v);
    vn = null([v'; n']);
    % find d s.t p + d*vn = seg(1,:) + t*v
    d = p*vn - seg(1,:)*vn;
    % find corresonding length along cutDir
    l = d/(cutDir'*vn);
    ix = abs(l) > r;
    if ~deleteOutside
        p(ix,:) = p(ix,:) - (l(ix) - sign(l(ix))*r)*cutDir';
    else
        removed = removed | ix;
    end
end
intsec.t = t;
intsec.p = p;
intsec.isClamped = clamped;
if any(removed)
    intsec = reindexNonEmpty(intsec, ~removed);
end
end

% -------------------------------------------------------------------------
function intsec = clampEllipsoid(intsec, seg, r2, cutDir, deleteOutside)
% center at the middle of the segment
c  = mean(seg);
v  = diff(seg);
vu = v(:)/norm(v);
removed = false;
p = intsec.p;
clamped = false(size(p,1), 1);
if ~isempty(r2) && isfinite(r2)
    r1 = norm(v)/2;
    pc = bsxfun(@minus, p, c);
    
    X  = [vu, cutDir];
    p2 = pc*X;
    tmp   = (p2(:,1)/r1).^2 + (p2(:,2)/r2).^2;
    scale = 1./sqrt(tmp);
    ix = scale < 1;
    if ~deleteOutside
        shift = bsxfun(@times, p2(ix,:), 1-scale(ix));
        p(ix,:) = p(ix,:) - shift*X';
        clamped = ix;
    else
        %p = p(~ix,:);
        removed = ix;
    end
end
intsec.isClamped = clamped;
intsec.p = p;
if any(removed)
    intsec = reindexNonEmpty(intsec, ~removed);
end
% also get length along segment
intsec.t = intsec.p*vu - seg(1,:)*vu;
end

% -------------------------------------------------------------------------    
function [r, v] = getEllipse(n, r, Q)
% get radius and principle axis of cut-plane ellipse from 
% normal plane: n'*x = 0
% ellipsoid: || (Q'*x)./r || = 1
% change of variables:
% u -> (Q'*x)./r
% plane in u-system: m'*u = 0, m = (Q'*n).*r
m  = (Q'*n).*r(:);
% basis for plane in u-system
Qu = null(m');
% circle in u-space: Qu*[cos(t); sin(t)], 0<=t<=2pi
% maps to ellipse in x-space: V*[cos(t); sin(t)], 0<=t<=2pi, W = Q'*Dr*Qu 
Dr = diag(r(:));
W  = Q*Dr*Qu;
% find one extremum corresponding to one of the ellipse main axis
tmp = W'*W;
[w11, w12, w22] = deal(tmp(1,1), tmp(1,2), tmp(2,2));
% differentiate and set to zero to get theta
t  = atan2(2*w12, w11-w22)/2;
v1 = W*[cos(t);sin(t)];
v2 =  W*[cos(t+pi/2);sin(t+pi/2)];
r  = [norm(v1), norm(v2)];
v  = [v1/r(1), v2/r(2)];
end

%----------------------------------------------------------------------
function s = reindexNonEmpty(s, ix)
fn = fieldnames(s);
for k = 1:numel(fn)
    if ~isempty(s.(fn{k}))
        s.(fn{k}) = s.(fn{k})(ix,:);
    end
end
end

%----------------------------------------------------------------------
function s = vertcatStructFields(s)
fn = fieldnames(s);
for k = 1:numel(fn)
    tmp.(fn{k}) = vertcat(s.(fn{k}));
end
s = tmp;
end


